Введение
Основная работа программистов-это умение работать с памятью. Порядочный программист должен обладать знаниями о хранение данных в памяти, о том что память статическая, автоматическая и динамическая. Сегодня речь пойдёт о динамическом выделение памяти и управлению ею. Динамическое управление занимается тем, что выделяет память по запросу приложения. Если бы процесс был один, то думать было бы нечего. Просто можно было отдать все что есть, но в многозадачной операционной системе так поступать нельзя. Такой ценный ресурс как память может понадобиться любому процессу в абсолютно любой момент времени. Такой важный вопрос как распределение памяти между различными процессами находится в ведении операционной системы.
Наверняка вам уже приходилось работать с ручным управлением памятью, выделать и освобождать память при помощи функций malloc/free( в C) или new/delete(в C++). Определение того, когда выделяется память, как правило, тривиально и не вызывает проблем. Реальной проблемой является уничтожение алгоритма - определение того, когда объект больше не нужен (т.е. является мусором), обычно эта задача также стоит за программистом, а если уничтожения не происходит, то это приводит к утечкам памяти, но сегодня не об этом. Рядовой программист не всегда внедряется в глубокий анализ сущности функций управляющие памятью. Пропуская тот момент, что базовые аллокаторы(по другому распределители памяти) не так уж и эффективны и имеют ряд проблем. Существует ряд стратегий управлений памятью. К примеру, популярный алгоритм 
-first-fit Распределитель памяти просматривает список областей до тех пор, пока не находит достаточ¬но большой свободный участок Затем этот участок делится на две части: одна отдается процессу, а другая остается неиспользуемой. Так происходит всегда, кроме статистически нереального случая точного соответствия свободного участ¬ка и процесса. Это быстрый алгоритм, потому что поиск уменьшен настолько, на¬сколько возможно. 
-best-fit Он выполняет поиск по всему списку и выбирает наименьший по размеру подходящий свободный фрагмент. Вместо того чтобы делить большую незанятую область, которая может понадобиться позже, этот алгоритм пытается найти учас¬ток, близко подходящий к действительно необходимым размерам.
Алгоритм, который мы сегодня просмотрим более подробно - называется buddy system (алгоритм близницов/двойников/приятелей.) Суть этого метода заключается в организации отдельных списков доступных блоков каждого размера 2^k, 0<=k<=m. Весь пул распределяемого пространства памяти состоит из 2^m слов, адреса которых, предположим, находятся в диапазоне от 0 до 2^m - 1.  Изначально весь блок из 2^m слов свободен. Позже, при требовании блока из 2^k слов и отсутствии свободного блока такого размера больший доступный блок разбивается на две равные части; в конечном итоге появится блок необходимого размера 2^k. Когда один блок разделяется на два(каждый половинного размера по сравнению с исходным), эти блоки называются двойниками(близнецами, buddies) Позже, когда оба двойника вновь становятся свободны, они объединяются в один большой блок. Таким образом, процесс выделения и освобождения может осуществляться бесконечно, если только в какой-то момент вся доступная память не окажется занятой. Но он может существенно увеличить непродуктивное расходование памяти, например если мы запросим блок размером в 518 бит, то удовлетворить запрос мы можем только блоком в 1024 бит, а этом алгоритме мы не можем разделить блок в 1024 бит на 518 и 506 бит, поэтому в блоке в 1024 бит будет находиться пустое неиспользованное пространство. Мы можем модифицировать алгоритм, использовав ещё одну стратегию, которая называется slab allocation. Идея такого распределителя состоит в том, что запросы на выделение памяти под объекты равного размера удовлетворяются из области одного кэша (слаба), а запросы на объекты другого размера (пусть отличающиеся от первого случая самым незначительным образом) - удовлетворяются из совершенно другого такого же кэша.
Сам термин слаб переводится близко к «облицовочная плитка», и принцип очень похож: любую вынутую из плоскости плитку можно заменить другой такой же, потому что их размеры в точности совпадают.
Распределитель плит имеет три основные цели:
•	Выделение небольших блоков памяти для устранения внутренней фрагментации, в противном случае это было бы вызвано системой приятелей;
•	Кэширование часто используемых объектов, чтобы система не тратила время
на выделение, инициализацию и уничтожение объектов
Аллокатор Slab фактически основан на алгоритме buddy. Пространство памяти, используемое распределителем Slab, выделяется через алгоритм близнецов, но Slab реализует свой собственный алгоритм для этих областей памяти, а затем управляет небольшими блоками памяти.
Slab впервые был введен в ядре Solaris 2. Джеффом Бонвиком. В настоящее время он широко используется многими Unix и Unix-подобными операционными системами, включая FreeBSD и Linux. 
 

Список литературы
1.	https://poisk-ru.ru/s61380t20.html
2.	https://www.geeksforgeeks.org/operating-system-allocating-kernel-memory-buddy-system-slab-system/
3.	https://en.wikipedia.org/wiki/Buddy_memory_allocation (статья с Вики)
4.	https://sci-hub.cat/downloads/2019-11-23/dc/feng2019.pdf?rand=633ab33a3dc40?download=true (https://ieeexplore.ieee.org/abstract/document/8759177/references#references)
5.	Кнут, Дональд (1997). Фундаментальные алгоритмы. Искусство компьютерного программирования. Том 1 (Второе изд.). Рединг, Массачусетс: Эддисон-Уэсли. стр. 435-455. ISBN 0-201-89683-4.
6.	http://www.csl.ece.upatras.gr/os/Silberschatz.pdf
7.	https://students.mimuw.edu.pl/ZSO/Wyklady/06_memory2/BuddySlabAllocator.pdf
8.	https://russianblogs.com/article/1034274803/
9.	https://cs.stackexchange.com/questions/152260/buddy-system-allocator-and-slab-allocator-in-linux-kernel
10.	https://www.youtube.com/watch?v=pFi-JKgoX-I
11.	https://ru.wikipedia.org/wiki/Slab
12.	https://web.archive.org/web/20160831101859/http://k806.ru/osprogram/os_2011-11-12.pdf#page=26
13.	https://www.programmersought.com/article/35715057658/
14.	https://www.youtube.com/watch?v=DRAHRJEAEso
15.	https://russianblogs.com/article/895968699/
16.	https://russianblogs.com/article/261428559/
17.	http://www.helenos.org/doc/design/html.chunked/mm.html
18.	https://forum.osdev.org/viewtopic.php?f=15&t=30717
19.	http://www.brokenthorn.com/Resources/OSDev26.html
20.	https://ru.wikipedia.org/wiki/Динамическое_распределение_памяти
21.	https://studwood.net/1601074/informatika/sistema_dvoynikov
22.	https://revolution.allbest.ru/programming/00674849_0.html
23.	https://tproger.ru/articles/memory-model/
24.	https://www.memorymanagement.org/mmref/alloc.html
25.	https://wikixw.ru/Управление_памятью
26.	http://s2.bitdl.ir/Ebook/Computer%20Science/Blunden%20-%20Memory%20Management%20-%20Algor.%20and%20Impl.%20in%20C-C++%20(Wordware,%202002).pdf
27.	https://sci-hub.ru/https://dl.acm.org/doi/abs/10.1145/359605.359626
28.	https://sci-hub.ru/https://link.springer.com/chapter/10.1007/3-540-60368-9_19
29.	https://dzen.ru/media/id/5eba7f439f339d116671be06/model-pamiati-v-iazykah-programmirovaniia-5f45f576cc336558bd7368cd
