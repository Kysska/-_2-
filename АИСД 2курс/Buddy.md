## Алгоритм управлению памятью
### Содержание
[Введение](#intro)

[Алгоритм двойников/близнецов(buddy system)](#buddy)

[Виртуальная память](#virt)

[Buddy and Slab allocator](#slab)

[Глоссарий](#gloss)

[Список источников](#listliter)


<a name="intro"></a> 
### Введение
Под памятью(memory) как правило подразумевается оперативная память[[1]](#gloss) компьютера.
Память является важнейшим ресурсом, требующим тщательного управления со стороны операционной систем[[2]](#gloss). 
Функциями ОС(операционной системы) по управлению памятью в системе являются: 
•	- отслеживание свободной и занятой памяти; 
•	- выделение памяти процессам и освобождение памяти по завершении процессов; 
•	- настройка адресов программы на конкретную область физической памяти.
Главной операцией управления памятью является размещение программы в основной памяти. Практически во всех современных операционных системах эта задача предполагает использование сложной схемы, известной как виртуальная память. Виртуальная память, в свою очередь, основана на использовании  - сегментации (segmentatioп) и/или страничной организации памяти (paging). Мы ещё более подробно разберёмся с виртуальной памятью, но для большего понимания темы данной работы остановимся на управление только оперативной(физической/реальной) памятью.

Простейшая схема управления оперативной памяти- ее распределение на области с фиксированными границами. Процесс(*процесс — это в выполняемая в данный момент программа.*) может быть загружен в раздел равного или большего размера. На картинке 1.1. показаны два варианта фиксированного распределения, память делится на фреймы(*кадр(frame)-блок основной памяти фиксированной длины*) одинакового или разных размеров.
![](./Picture/%D0%A0%D0%B8%D1%81%D1%83%D0%BD%D0%BE%D0%BA1.png) *рис.1.1 Фиксированное расспределение памяти*

 Реализация такого распределения достаточна проста. Но к примеру, мы хотим выделить память размером менее мегабайта, всё что может сделать операционная система это выделить целиком раздел в 8 Мбайт, при этом останется неиспользованное 7 Мбайт блока, что не есть хорошо, данная проблема называется *внутренней фрагментаций*(internal fragmentation)(спойлер: существует ещё и внешняя фрагментация). Такая ошибка будет наблюдаться и в фрагментации блоков разного размера. Но прогресс не стоит на месте и фиксированное распределение памяти в своё время было заменено на динамическое(которое сейчас вытеснено более эффективными технологиями). При размещении процесса в основной памяти для него выделяется строго необходимое количество памяти. К примеру, загрузим три процесса в память, после третьего процесса в основной памяти остается пустое пространство, которое уже с меньшей вероятностью будет использовано, так как оно слишком мало, такая проблема уже называется внешней фрагментацией. 
![](/Picture/%D0%A0%D0%B8%D1%81%D1%83%D0%BD%D0%BE%D0%BA2.png)
  *рис.1.2.Динамическое расспределение памяти и внешняя фрагментация*

т.е. *Фрагментация*-это явление, при котором пространство памяти, используется неэффективно. Фрагментация приводит к "потраченному впустую" пространству в памяти. Существует внутренняя и внешняя фрагментация, внутренняя это когда, так называемая “дыра”, появляется внутри фрейма, а внешняя в свою очередь, образует “дыры” между фреймами. 
При дальнейшем освобождении и выделении памяти, свободных мелких блоков, становится всё больше, поэтому нужно с этим как-то справляться.
 ![](/Picture/%D0%A0%D0%B8%D1%81%D1%83%D0%BD%D0%BE%D0%BA7.png) *рис.1.3 Продолжение рис.1.2. Увеличение внешней фрагментации*
К примеру, применить уплотнение. время от времени операционная система перемещает процессы в памяти так, чтобы они занимали смежные области памяти; Но такое решение затратно по времени и лучше работают алгоритмы размещения процессов в памяти. 

Существует ряд стратегий для осуществления выбора блока памяти.
  •	*Метод наилучшего подходящего* выбирает блок, размер которого наиболее близок к требуемому; 
  ![](%D0%A0%D0%B8%D1%81%D1%83%D0%BD%D0%BE%D0%BA5.png)
  *рис.1.4 Метод наилучшего подходящего*
  •	*Метод первого подходящего* проверяет все свободные блоки с начала памяти и выбирает первый достаточный по размеру для размещения процесса
 ![](%D0%A0%D0%B8%D1%81%D1%83%D0%BD%D0%BE%D0%BA4.png)
 *рис.1.5 Метод первого подходящего*
  •	*Наихудший подходящий* при поступлении запроса выделит блок памяти самый большой по объему, в котором достаточно места для размещение ещё одного процесса.
 ![](%D0%A0%D0%B8%D1%81%D1%83%D0%BD%D0%BE%D0%BA6.png)
 *рис.1.6 Метод наихудшего подходящего*

Метод наилучшего подходящего, вопреки своему названию, оказывается, как правило, наихудшим. Так как он ищет блоки, наиболее близкие по размеру к требуемому, он оставляет после себя множество очень маленьких блоков, к тому же тратится много времени для просмотра всего списка свободных блоков. Алгоритм первого подходящего обычно засоряет начало памяти небольшими свободными блоками, что приводит к увеличению времени поиска подходящего блока в последующем.
<a name="buddy"></a> 
### Система двойников/близнецов(buddy system)

Как фиксированное, так и динамическое распределение памяти имеют свои недостатки. Фиксированное распределение ограничивает количество активных процессов и неэффективно использует память при несоответствии между размерами разделов и процессов. Динамическое распределение реализуется более сложно и включает накладные расходы по уплотнению памяти. Интересным компромиссом в этом плане является система двойников . В системе двойников память распределяется блоками размером 2^k, L <= К <= U, где 
>2^L - минимальный размер выделяемого блока памяти;
>2^U - наибольший распределяемый блок; вообще говоря;

2^U представляет собой размер всей доступной для распределения памяти. Позже, при требовании блока из 2^k и отсутствии свободного блока такого размера больший доступный блок разбивается на две равные части, пока в итоге не появится необходимого размер 2^K. Когда один блок разбивается на два, эти блоки будут называться *двойниками*(близнецами,buddy). 
![](/Picture/%D0%A1%D0%BA%D1%80%D0%B8%D0%BD%D1%88%D0%BE%D1%82%2004-11-2022%20172936.jpg)
*рис.2.1 Пример расспределителя близнецов*
Система двойников постоянно ведет список доступных блоков для каждого размера 2^i. Свободный блок может быть удален из списка (i+1} разделением ее пополам и внесением двух новых блоков размером 2^i в список i. Когда пара двойников в списке i оказывается освобожденной, они удаляются из списка и объединяются в единый блок в списке (i+ 1). 
Псевдо код, в котором осуществляется поиск свободного блока:
```
void get_hole(int i){
  if(i == (U+1)){
    if(<Список i пуст>){
      get_hole{i+1};
      <Разделить блока на два>
      <Поместить двойники в список i>
    }
    <Взять первый свободный блок из списка i>
  }
}
```
Ключевой факт, лежащий в основе практической ценности этого метода, состоит в том, что если известен адрес блока и его размер, то и известен адрес его двойника. Например, двойником блока с размером 16 с двоичным адресом 101110010110000 является блок с двоичным адресов 101110010100000. Блок размером 32 имеет адрес вида xxx...xx00000(где иксы представляют собой 0 и 1); при разделении блоки-двойники имеют адреса xx...x00000 и xx...x10000. 
Это функция легко вычисляется с помощью операции исключающее или(XOR).

Рассмотрим алгоритм на примерах. 
Пример: **выделить(256)->выделить(128)->выделить(64)**

*Шаги:*
1.	Вся доступная память 1024мб разделится  на 2 блока А и А’ по 512мб
2.	512мб в свою очередь разделится на два блока B и B’ по 256мб, один блок B поместится в лист свободных блоков, второй будет использован.
3.	Свободный блок B’ разделится по 128мб, C блок используется, C’ в лист
4.	С’ делим на D и D’, один занимает, другой в лист
Итого: 3 блока B, C, D заняты, в списке 64 присутствует свободный D’, в списке 512 свободный A’

![](/Picture/%D0%A0%D0%B8%D1%81%D1%83%D0%BD%D0%BE%D0%BA9.png)
*Рис.2.2 Первый цикл работы алгоритма*

**выделить(128)-> освободить(C, 128)->освободить(D,64)**

1.блок в 128 можем получить за счёт деления A’ сначала на Е и Е’, затем Е на F и F’
2. F занимаем, F’ и E’ свободны
3. C отправляется в список, он не может быть объединен в более больший блок, так как C’ частично занят
4.D освобождается, D и D’ объединяются, С и C’ объединяются, блок B’ в список 
![](%D0%A0%D0%B8%D1%81%D1%83%D0%BD%D0%BE%D0%BA10.png)
*рис.2.3 Второй цикл работы алгоритма*
![](%D0%A0%D0%B8%D1%81%D1%83%D0%BD%D0%BE%D0%BA11.png)
*рис.2.4 Третий цикл работы алгоритма*

На рис.2.5 представлен алгоритм в представлении бинарного дерева. Листья представляют текущее распределение памяти. Если два двойника являются листьями, то по крайней мере один из них занят; в противном случае они должны слиться в блок большего размера.
 ![](%D0%A0%D0%B8%D1%81%D1%83%D0%BD%D0%BE%D0%BA12.png)
 *рис.2.5.Бинарное представление алгоритма*

Возьмём ещё один пример, выделим блок размером 9кб, алгоритм выдаст блок размером 16кб, оставляя 7кб незанятыми, и снова проблема в фрагментации(а именно внутренней фрагментации), которую хотелось бы решить, промодефицировать алгоритм.   
Модифицированная версия системы двойников используется для распределения памяти ядром UNIX, Linux. Внедримся в понятия виртуальной памяти, чтобы понять каким образом применяется алгоритм на сегодняшний день в ОС. 
<a name="virt"></a> 
####Виртуальная память  
Виртуальная память (англ. virtual memory) — метод управления памятью компьютера, позволяющий выполнять программы, требующие больше оперативной памяти, чем имеется в компьютере, путём автоматического перемещения частей программы между основной памятью и вторичным хранилищем (например, жёстким диском). Для выполняющейся программы данный метод полностью прозрачен и не требует дополнительных усилий со стороны программиста, однако реализация этого метода требует как аппаратной поддержки, так и поддержки со стороны операционной системы.
В системе с виртуальной памятью используемые программами адреса, называемые *виртуальными адресами*, транслируются в физические адреса в памяти компьютера. Трансляцию виртуальных адресов в физические выполняет аппаратное обеспечение, называемое блоком управления памятью.
 ![](%D0%A1%D0%BA%D1%80%D0%B8%D0%BD%D1%88%D0%BE%D1%82%2029-10-2022%20140926.jpg)
 *рис.3.1 Визуализация виртуальной памяти*

 Для программы основная память выглядит как доступное и непрерывное адресное пространство либо как набор непрерывных сегментов, вне зависимости от наличия у компьютера соответствующего объёма оперативной памяти. Управление виртуальными адресными пространствами, соотнесение физической и виртуальной памяти, а также перемещение фрагментов памяти между основным и вторичным хранилищами выполняет операционная система.
Применение виртуальной памяти позволяет:
•	освободить программиста от необходимости вручную управлять загрузкой частей программы в память и согласовывать использование памяти с другими программами
•	предоставлять программам больше памяти, чем физически установлено в системе
•	в многозадачных системах изолировать выполняющиеся программы друг от друга путём назначения им непересекающихся адресных пространств
 
В большинстве современных операционных систем виртуальная память организуется с помощью страничной адресации. Оперативная память делится на страницы: области памяти фиксированной длины (например, 4096 байт), которые являются минимальной единицей выделяемой памяти (то есть даже запрос на 1 байт от приложения приведёт к выделению ему страницы памяти). Исполняемый процессором пользовательский поток обращается к памяти с помощью адреса виртуальной памяти, который делится на номер страницы и смещение внутри страницы. 
<a name="slab"></a> 
### Buddy system and slab
Вернёмся к теме реферата. В контексте ОС(операционных систем) нового времени buddy system, принимает на себя роль расспределителя страниц. Все свободные фреймы страниц сгруппированы в список из 11 блоков, каждый список блоков содержит блоки фреймов страниц размером 1, 2, 4, 8, 16, 32, 64, 128, 256, 512 и 1024.
![](%D0%A0%D0%B8%D1%81%D1%83%D0%BD%D0%BE%D0%BA13.png)
*рис.4.1 Список свободных страниц*

К примеру, в Linux buddy system управляет и выделяет память в единицах страниц. Но по сути существет потребность выделение блоков памяти в байтах. Если нам нужно подать заявку на 20 байт, мы не можем выделить страницу. Это серьезная трата памяти. Расспределитель, который был создан для небольшого выделения памяти,называется Slab, выбирающий блоки памяти при помощи buddy алгоритма, а затем нарезающий из этих блоков более мелкие "куски" и управляющий ими по отдельности. На машинах х86 размер страницы составляет 4 Кбайт, а участки памяти, выделяемые в пределах страницы, могут иметь размеры 32, 64, 128, 252, 508, 2040 и 4080 байт.  Поскольку ядро часто создает и уничтожает объекты определенных типов (например,task_struct), то оно зависит от так называемых кэшей объектов (object caches). Эти кэши состоят из указателей на один или несколько кусков(slab, плит), в которых может храниться несколько объектов одного типа. 
Блоки занимают одну или несколько физически смежных страниц памяти. Обычно блок занимает только одну страницу памяти. Каждый кеш может содержать несколько блоков. Каждый из этих кусков может быть полным, частично заполненным или пустым. 
 1. Пустой SLAB – все объекты в slab помечены как свободные.
 2. Частичный заполненный SLAB состоит как из используемых, так и из свободных объектов
 3. Полный SLAB – все объекты, помеченные как используемые.
 Участки могут быть разделены на меньшие или объединены, подобно разделению и слиянию блоков в алгоритме двойников, и перемещаться из одного списка в другой соответственно изменению их размеров. 

Например, когда ядру нужно выделить новый дескриптор процесса (то есть новую task_struct), оно ищет в кэше объектов структуры задач и сначала пытается найти частично заполненный кусок и выделить новую task_struct в нем. Если такого куска нет, то оно просматривает список пустых кусков. Наконец (при необходимости) оно выделит новый кусок, поместит в него новую структуру задач и свяжет этот кусок с кэшем объектов структур задач.
![](%D0%A1%D0%BA%D1%80%D0%B8%D0%BD%D1%88%D0%BE%D1%82%2029-10-2022%20205421.jpg)
Кэш описывается структурой kmem_cache (также называемой «дескриптором кэша»):
```
struct kmem_cache {
// ...
unsigned int num; // количество объектов в slab
unsigned int gfporder; // логарифмическое число смежных фреймов страницы в skab
const char *name; // имя кеша
int obj_size; // размер объекта в кеше
struct kmem_list3 **nodelists; // пустой/частичный/полный slab
};
```
Объекты сами по себе хранятся в slab’ах, которые представляют собой один или несколько фреймов смежных страниц. Единичный slab может хранить числовые объекты размером obj_size. Например, slab, распределенный по единичной странице (размером 4096 байт), может хранить 4 объекта размером 1024 байта.

Статус единичного slab (например, количество свободных объектов) описывается структурой slab (также называемой «структурой управления slab»):
```
struct slab {
 struct list_head list; /* Список заполненных, частично заполненных
 или пустых блоков */
 unsigned long colouroff; /* Смещение для окрашивания блока */
 void *s_mem; /* Указатель на первый объект блока */
 unsigned int inuse; /* Количество выделенных объектов */
 kmem_bufctl_t free; /* Первый свободный объект, если есть */
};
```
В SLUB кэши общего назначения идут с префиксом «kmalloc-» (например, «kmalloc‑32», ...)
Чтобы выделить/освободить память в кэше общего назначения, ядро использует функции kmalloc() и kfree().

Поскольку некоторые объекты будут размещаться/освобождаться много раз, ядро создает специальные «назначенные» кэши. Например, структура file как объект используется во многих местах, у которого есть специальный назначенный кэш filp. Создание назначенного кэша для этих объектов гарантирует, что внутренняя фрагментация тех кэшей будет около нуля.

Чтобы выделить/освободить память в назначенном кэше, ядро использует функции kmem_cache_alloc() и kmem_cache_free().

<a name="gloss"></a> 
### Глоссарий
1. Оперативная память (сокращенно ОЗУ/RAM) — это элемент компьютерной системы, который отвечает за временное хранение исполняемого кода операционной системы и установленных программ.
2. Операцио́нная систе́ма, сокр. ОС — комплекс взаимосвязанных программ, предназначенных для управления ресурсами компьютера и организации взаимодействия с пользователем.
3. Процесс — это в выполняемая в данный момент программа.
4. Кадр(frame)-блок основной памяти фиксированной длины
5. Фрагментация - это явление, при котором пространство памяти, основного или дополнительного хранилища, используется неэффективно, уменьшая емкость или производительность, а часто и то, и другое. 
6. Внутренняя фрагментация — это тип фрагментации, который имеет место, когда программе выделяется больший объем памяти, чем необходимый. Это происходит, когда память распределяется по блокам фиксированного размера.
7. Внешняя фрагментация — это дыры или неиспользуемое пространство, которое возникает среди незаразной памяти или фрагментов хранилища и слишком мало для хранения новой программы.
8. Страничная память — способ организации виртуальной памяти, при котором виртуальные адреса отображаются на физические постранично. Для 32-битной архитектуры x86 минимальный размер страницы равен 4096 байт.
9. Ядро́ (англ. kernel) — центральная часть операционной системы (ОС), обеспечивающая приложениям координированный доступ к ресурсам компьютера, таким как процессорное время, память, внешнее аппаратное обеспечение, внешнее устройство ввода и вывода информации.
10. Аллокатор — это часть программы, которая запрашивает память большими кусками напрямую у ОС через системные вызовы

<a name="listliter"></a> 
### Список литературы
1.	https://poisk-ru.ru/s61380t20.html
2.	https://www.geeksforgeeks.org/operating-system-allocating-kernel-memory-buddy-system-slab-system/
3.	https://en.wikipedia.org/wiki/Buddy_memory_allocation (статья с Вики)
4.	https://sci-hub.cat/downloads/2019-11-23/dc/feng2019.pdf?rand=633ab33a3dc40?download=true (https://ieeexplore.ieee.org/abstract/document/8759177/references#references)
5.	Кнут, Дональд (1997). Фундаментальные алгоритмы. Искусство компьютерного программирования. Том 1 (Второе изд.). Рединг, Массачусетс: Эддисон-Уэсли. стр. 435-455. ISBN 0-201-89683-4.
6.	http://www.csl.ece.upatras.gr/os/Silberschatz.pdf
7.	https://students.mimuw.edu.pl/ZSO/Wyklady/06_memory2/BuddySlabAllocator.pdf
8.	https://russianblogs.com/article/1034274803/
9.	https://cs.stackexchange.com/questions/152260/buddy-system-allocator-and-slab-allocator-in-linux-kernel
10.	https://www.youtube.com/watch?v=pFi-JKgoX-I
11.	https://ru.wikipedia.org/wiki/Slab
12.	https://web.archive.org/web/20160831101859/http://k806.ru/osprogram/os_2011-11-12.pdf#page=26
13.	https://www.programmersought.com/article/35715057658/
14.	https://www.youtube.com/watch?v=DRAHRJEAEso
15.	https://russianblogs.com/article/895968699/
16.	https://russianblogs.com/article/261428559/
17.	http://www.helenos.org/doc/design/html.chunked/mm.html
18.	https://forum.osdev.org/viewtopic.php?f=15&t=30717
19.	http://www.brokenthorn.com/Resources/OSDev26.html
20.	https://ru.wikipedia.org/wiki/Динамическое_распределение_памяти
21.	https://studwood.net/1601074/informatika/sistema_dvoynikov
22.	https://revolution.allbest.ru/programming/00674849_0.html
23.	https://tproger.ru/articles/memory-model/
24.	https://www.memorymanagement.org/mmref/alloc.html
25.	https://wikixw.ru/Управление_памятью
26.	http://s2.bitdl.ir/Ebook/Computer%20Science/Blunden%20-%20Memory%20Management%20-%20Algor.%20and%20Impl.%20in%20C-C++%20(Wordware,%202002).pdf
27.	https://sci-hub.ru/https://dl.acm.org/doi/abs/10.1145/359605.359626
28.	https://sci-hub.ru/https://link.springer.com/chapter/10.1007/3-540-60368-9_19
29.	https://dzen.ru/media/id/5eba7f439f339d116671be06/model-pamiati-v-iazykah-programmirovaniia-5f45f576cc336558bd7368cd
